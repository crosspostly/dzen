// ü§ñ CI/CD Version - Full Automation with Environment Variable Cookies
const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');

// üìã Configuration
const CONFIG = {
  cookiesSource: process.env.CI ? 'ENVIRONMENT' : 'FILE',
  cookiesPath: path.join(__dirname, '../config/cookies.json'),
  feedPath: path.join(path.dirname(path.dirname(path.dirname(__dirname))), 'public', 'feed.xml'),
  historyPath: path.join(__dirname, '../published_articles.txt'),
  headless: process.env.HEADLESS !== 'false',
  timeout: 60000,
  navigationTimeout: 60000,
  waitTimeout: 30000
};

console.log('ü§ñ AUTO-PUBLISHER CONFIGURATION:');
console.log(`   Feed path: ${CONFIG.feedPath}`);
console.log(`   History path: ${CONFIG.historyPath}`);
console.log(`   Cookies source: ${CONFIG.cookiesSource}`);
console.log(`   Headless mode: ${CONFIG.headless}`);
console.log(`   Environment: ${process.env.CI ? 'CI/CD (GitHub Actions)' : 'Local'}\n`);

// üìñ Get articles from feed.xml
async function getArticlesFromFeed() {
  try {
    console.log(`üìÑ Opening feed: ${CONFIG.feedPath}`);
    const feedContent = await fs.readFile(CONFIG.feedPath, 'utf8');
    console.log(`‚úÖ Feed loaded: ${feedContent.length} characters`);
    
    const itemRegex = /<item>([\s\S]*?)<\/item>/g;
    const items = [];
    let match;
    
    while ((match = itemRegex.exec(feedContent)) !== null) {
      const itemContent = match[1];
      
      const titleMatch = itemContent.match(/<title><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<title>(.*?)<\/title>/);
      const title = titleMatch ? titleMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').trim() : 'Without title';
      
      const linkMatch = itemContent.match(/<link>(.*?)<\/link>/);
      const link = linkMatch ? linkMatch[1] : '';
      
      const mediaContentMatch = itemContent.match(/<media:content[^>]*url="(.*?)"[^>]*>/);
      const imageUrl = mediaContentMatch ? mediaContentMatch[1] : '';
      
      const dateMatch = itemContent.match(/<pubDate>(.*?)<\/pubDate>/);
      const pubDate = dateMatch ? dateMatch[1] : '';
      
      const descMatch = itemContent.match(/<description><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<description>(.*?)<\/description>/);
      const description = descMatch ? descMatch[1] : '';
      
      const contentMatch = itemContent.match(/<content:encoded><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<content:encoded>(.*?)<\/content:encoded>/);
      const content = contentMatch ? contentMatch[1] : description;
      
      items.push({ title, description, link, pubDate, imageUrl, content });
    }
    
    console.log(`üìÑ Found ${items.length} articles\n`);
    return items;
  } catch (error) {
    console.error(`‚ùå Error reading feed: ${error.message}`);
    return [];
  }
}

// üèÑ Process HTML content
function processArticleContent(content) {
  if (!content) return '';
  
  let processed = content
    // ‚úÖ 1. –£–¥–∞–ª—è–µ–º ANSI escape codes (–∫–∞–∫ –≤ normalizeTitle)
    //    –ü—Ä–∏–º–µ—Ä—ã: \x1b[31m, \x1b[0m –∏ —Ç.–ø.
    .replace(/\x1b\[[0-9;]*m/g, '')
    // ‚úÖ 2. –£–¥–∞–ª—è–µ–º –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω—ã–µ —É–ø—Ä–∞–≤–ª—è—é—â–∏–µ —Å–∏–º–≤–æ–ª—ã,
    //    –Ω–æ –ù–ï —Ç—Ä–æ–≥–∞–µ–º –ø–µ—Ä–µ–≤–æ–¥—ã —Å—Ç—Ä–æ–∫/—Ç–∞–±—É–ª—è—Ü–∏–∏, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É
    //    - –≤—ã—Ä–µ–∑–∞–µ–º: 0x00‚Äì0x08, 0x0B, 0x0C, 0x0E‚Äì0x1F, 0x7F‚Äì0x9F
    //    - –æ—Å—Ç–∞–≤–ª—è–µ–º: \x09 (TAB), \x0A (LF, \n), \x0D (CR, \r)
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '')
    
    // ===== –î–∞–ª—å—à–µ ‚Äî —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ª–æ–≥–∏–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã =====
    // <p>, </p> ‚Üí –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –º–µ–∂–¥—É –∞–±–∑–∞—Ü–∞–º–∏
    .replace(/<p[^>]*>/gi, '\n\n')
    .replace(/<\/p>/gi, '')
    // <h1-6> ‚Üí –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∞–±–∑–∞—Ü—ã
    .replace(/<h[1-6][^>]*>/gi, '\n\n')
    .replace(/<\/h[1-6]>/gi, '\n\n')
    // <div> ‚Üí –æ–¥–∏–Ω–∞—Ä–Ω—ã–π –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏
    .replace(/<div[^>]*>/gi, '\n')
    .replace(/<\/div>/gi, '\n')
    // <br> ‚Üí –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<br>/gi, '\n')
    // <li> ‚Üí –º–∞—Ä–∫–µ—Ä —Å–ø–∏—Å–∫–∞
    .replace(/<li[^>]*>/gi, '\n‚Ä¢ ')
    .replace(/<\/li>/gi, '')
    // –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ç–µ–≥–∏ —É–±–∏—Ä–∞–µ–º
    .replace(/<[^>]*>/g, '')
    // HTML entities ‚Üí —Ä–µ–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    .replace(/&nbsp;/g, ' ')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");  // ‚úÖ FIX: Correct HTML entity replacement
  
  // –°—Ö–ª–æ–ø—ã–≤–∞–µ–º —Ç—Ä–æ–π–Ω—ã–µ –∏ –±–æ–ª–µ–µ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ –¥–≤–æ–π–Ω—ã–µ
  processed = processed.replace(/\n\s*\n\s*\n+/g, '\n\n');
  return processed.trim();
}

// üìñ Load cookies
async function loadCookies() {
  try {
    let cookiesJson;
    
    if (process.env.CI) {
      cookiesJson = process.env.DZEN_COOKIES_JSON;
      if (!cookiesJson || cookiesJson.length < 10) {
        throw new Error('DZEN_COOKIES_JSON environment variable is empty!');
      }
      console.log(`üîê Cookies loaded from environment variable (${cookiesJson.length} chars)`);
    } else {
      cookiesJson = await fs.readFile(CONFIG.cookiesPath, 'utf8');
      console.log(`üîê Cookies loaded from file (${cookiesJson.length} chars)`);
    }
    
    const cookies = JSON.parse(cookiesJson);
    console.log(`‚úÖ Valid JSON (${Array.isArray(cookies) ? cookies.length : 1} items)\n`);
    return cookies;
  } catch (error) {
    console.error(`‚ùå Error loading cookies: ${error.message}`);
    throw error;
  }
}

// üìñ Read published articles
async function getPublishedArticles() {
  try {
    const content = await fs.readFile(CONFIG.historyPath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim());
    return lines.map(line => {
      const match = line.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - (.+)/);
      return match ? { date: match[1], title: match[2] } : null;
    }).filter(Boolean);
  } catch (error) {
    console.log(`‚ÑπÔ∏è  History file not found`);
    return [];
  }
}

// üîß Normalize title for comparison - removes invisible chars, HTML entities, etc.
function normalizeTitle(title) {
  if (!title) return '';
  
  return title
    // Remove ANSI escape codes
    .replace(/\x1b\[[0-9;]*m/g, '')
    // Remove other control characters
    .replace(/[\x00-\x1F\x7F-\x9F]/g, '')
    // Normalize HTML entities
    .replace(/&nbsp;/gi, ' ')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, "'")
    .replace(/&apos;/gi, "'")
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&amp;/gi, '&')
    // Normalize different types of quotes
    .replace(/[¬´¬ª""]/g, '"')
    .replace(/['']/g, "'")
    // Normalize different types of dashes
    .replace(/[‚Äî‚Äì]/g, '-')
    // Normalize whitespace (replace multiple spaces with single space)
    .replace(/\s+/g, ' ')
    // Trim
    .trim()
    // Lowercase for case-insensitive comparison
    .toLowerCase();
}

function isArticlePublished(articleTitle, publishedArticles) {
  const normalizedTarget = normalizeTitle(articleTitle);
  return publishedArticles.some(pub => {
    const normalizedPub = normalizeTitle(pub.title);
    return normalizedPub === normalizedTarget;
  });
}

function getFirstUnpublishedArticle(articles, publishedArticles) {
  console.log('üîç Checking for unpublished articles:\n');
  
  // üêõ DEBUG: Show published articles
  console.log('üìã PUBLISHED ARTICLES DEBUG:');
  if (publishedArticles.length === 0) {
    console.log('   (no published articles yet)\n');
  } else {
    publishedArticles.forEach((pub, idx) => {
      console.log(`   [${idx + 1}] "${pub.title}"`);
      console.log(`        Length: ${pub.title.length}`);
      console.log(`        Normalized: "${normalizeTitle(pub.title)}"`);
      console.log(`        Hex: ${pub.title.split('').map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ')}`);
    });
    console.log();
  }
  
  // üêõ DEBUG: Show articles from feed
  console.log('üì∞ ARTICLES FROM FEED DEBUG:');
  articles.forEach((art, idx) => {
    const isPublished = isArticlePublished(art.title, publishedArticles);
    const status = isPublished ? '‚úã Already published' : '‚úÖ NEW';
    
    console.log(`   [${idx + 1}/${articles.length}] ${status}`);
    console.log(`        Title: "${art.title}"`);
    console.log(`        Length: ${art.title.length}`);
    console.log(`        Normalized: "${normalizeTitle(art.title)}"`);
    console.log(`        Hex: ${art.title.split('').map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(' ')}`);
    console.log(`        Published: ${isPublished}`);
  });
  console.log();
  
  for (let i = 0; i < articles.length; i++) {
    const article = articles[i];
    if (!isArticlePublished(article.title, publishedArticles)) {
      return article;
    }
  }
  return null;
}

async function savePublishedArticle(article) {
  const date = new Date().toISOString().replace('T', ' ').substring(0, 19);
  const entry = `${date} - ${article.title}\n`;
  try {
    await fs.appendFile(CONFIG.historyPath, entry);
    console.log(`‚úÖ Saved to history: "${article.title.substring(0, 50)}..."`);
  } catch (error) {
    console.error(`‚ùå Error saving: ${error.message}`);
  }
}

// üé≠ HUMAN-LIKE BEHAVIOR FUNCTIONS

// Random delay between actions (simulates human thinking/reading time)
async function randomDelay(page, min = 500, max = 2000) {
  const delay = Math.floor(Math.random() * (max - min + 1)) + min;
  console.log(`   ‚è±Ô∏è  Random delay: ${delay}ms`);
  await page.waitForTimeout(delay);
}

// Move mouse naturally (simulates human mouse movement)
async function moveMouseNaturally(page, x, y) {
  const steps = Math.floor(Math.random() * 6) + 5; // 5-10 steps
  const currentPos = await page.evaluate(() => ({ x: window.mouseX || 0, y: window.mouseY || 0 }));
  
  for (let i = 0; i < steps; i++) {
    const progress = (i + 1) / steps;
    const randomX = currentPos.x + (x - currentPos.x) * progress + (Math.random() - 0.5) * 30;
    const randomY = currentPos.y + (y - currentPos.y) * progress + (Math.random() - 0.5) * 30;
    await page.mouse.move(randomX, randomY);
    await page.waitForTimeout(Math.floor(Math.random() * 30) + 20);
  }
  
  await page.mouse.move(x, y);
  await page.evaluate((mx, my) => { window.mouseX = mx; window.mouseY = my; }, x, y);
}

// Type text naturally (simulates human typing with pauses)
async function typeNaturally(element, text, page) {
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    await element.type(char);
    
    // Variable typing speed (faster for common words, slower for complex parts)
    let delay = Math.floor(Math.random() * 50) + 30; // 30-80ms base
    
    // Add pauses at punctuation (simulates thinking)
    if (['.', ',', '!', '?', ';', ':'].includes(char)) {
      delay += Math.floor(Math.random() * 200) + 100; // +100-300ms
    }
    
    // Occasional longer pause (simulates re-reading or thinking)
    if (Math.random() < 0.05) {
      delay += Math.floor(Math.random() * 300) + 200; // +200-500ms
    }
    
    await page.waitForTimeout(delay);
  }
}

// Scroll page naturally (simulates human scrolling)
async function scrollNaturally(page, direction = 'down', amount = 200) {
  const scrollSteps = Math.floor(Math.random() * 3) + 3; // 3-5 steps
  const stepAmount = amount / scrollSteps;
  
  for (let i = 0; i < scrollSteps; i++) {
    await page.evaluate((step, dir) => {
      window.scrollBy(0, dir === 'down' ? step : -step);
    }, stepAmount, direction);
    await page.waitForTimeout(Math.floor(Math.random() * 50) + 30);
  }
}

// Click with human-like behavior
async function clickNaturally(page, element) {
  const box = await element.boundingBox();
  if (box) {
    // Move mouse to element with slight randomness
    const x = box.x + box.width / 2 + (Math.random() - 0.5) * 20;
    const y = box.y + box.height / 2 + (Math.random() - 0.5) * 20;
    
    await moveMouseNaturally(page, x, y);
    await randomDelay(page, 100, 300);
    
    // Sometimes scroll element into view first
    if (Math.random() < 0.3) {
      await element.scrollIntoViewIfNeeded();
      await randomDelay(page, 200, 400);
    }
    
    await element.click();
  } else {
    // Fallback if no bounding box
    await element.click();
  }
}

// ü§ñ Main function
(async () => {
  console.log('ü§ñ ==== AUTO-PUBLISHER STARTING ====\n');
  
  try {
    const cookies = await loadCookies();
    const publishedArticles = await getPublishedArticles();
    const articles = await getArticlesFromFeed();
    
    if (articles.length === 0) {
      console.log('‚ùå No articles found in feed.xml');
      process.exit(0);
    }
    
    const article = getFirstUnpublishedArticle(articles, publishedArticles);
    
    if (!article) {
      console.log('\n‚úÖ All articles already published');
      process.exit(0);
    }
    
    console.log(`\nüìù Found article: "${article.title.substring(0, 50)}..."`);
    const processedContent = processArticleContent(article.content);
    console.log(`‚úÖ Content ready: ${processedContent.length} chars`);
    
    // Launch browser
    console.log('\nüåê Launching browser...');
    
    const browser = await chromium.launch({
      headless: CONFIG.headless,
      args: ['--no-sandbox', '--disable-blink-features=AutomationControlled', '--disable-dev-shm-usage']
    });
    
    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    
    const page = await context.newPage();
    
    try {
      await context.addCookies(cookies);
      console.log(`‚úÖ Cookies loaded (${cookies.length} cookies)`);
    } catch (error) {
      console.error(`‚ùå Error adding cookies: ${error.message}`);
      await browser.close();
      process.exit(1);
    }
    
    // Navigate
    console.log('üåê Navigating to Dzen editor...');
    await page.goto('https://dzen.ru/profile/editor/potemki', {
      waitUntil: 'domcontentloaded',
      timeout: CONFIG.navigationTimeout
    });
    
    console.log('‚úÖ Page loaded');
    await randomDelay(page, 3000, 5000);
    
    // üé≠ Simulate human-like page exploration
    console.log('üé≠ Human simulation: Exploring page...');
    await scrollNaturally(page, 'down', 100);
    await randomDelay(page, 800, 1500);
    
    // Close modal
    const modalButton = await page.$('[data-testid="close-button"]');
    if (modalButton) {
      console.log('üé≠ Human simulation: Closing modal...');
      await clickNaturally(page, modalButton);
      await randomDelay(page, 1000, 2000);
    }
    
    // Click add publication
    const addButton = await page.$('[data-testid="add-publication-button"]');
    if (addButton) {
      console.log('üé≠ Human simulation: Clicking add publication...');
      await clickNaturally(page, addButton);
      console.log('‚úÖ Add publication button clicked');
      await randomDelay(page, 2000, 4000);
      
      // Click write article
      const writeButton = await page.$('text="–ù–∞–ø–∏—Å–∞—Ç—å —Å—Ç–∞—Ç—å—é"');
      if (writeButton) {
        console.log('üé≠ Human simulation: Clicking write article...');
        await clickNaturally(page, writeButton);
        console.log('‚úÖ "Write article" clicked');
        await randomDelay(page, 6000, 10000);
        
        // Close popups
        console.log('üé≠ Human simulation: Closing popups...');
        await page.evaluate(() => {
          const overlays = document.querySelectorAll('.ReactModal__Overlay, .ReactModalPortal, .article-editor-desktop--help-popup__overlay-3q');
          overlays.forEach(el => { el.style.display = 'none'; el.remove(); });
        });
        await randomDelay(page, 300, 700);
        await page.keyboard.press('Escape');
        await randomDelay(page, 3000, 5000);
        
        // Get input fields
        const inputs = await page.$$('input[type="text"], textarea, div[contenteditable="true"]');
        console.log(`\nüîç Found ${inputs.length} input fields`);
        
        // Fill title
        if (inputs.length > 0) {
          console.log(`\nüìù 1. Filling title with human-like typing...`);
          await inputs[0].focus();
          await randomDelay(page, 500, 1000);
          
          // üé≠ Use natural typing for title
          console.log('üé≠ Human simulation: Typing title naturally...');
          await typeNaturally(inputs[0], article.title, page);
          
          console.log(`‚úÖ Title filled`);
          await randomDelay(page, 800, 1500);
        }
        
        // Fill content
        if (inputs.length > 1) {
          console.log(`\nüìù 2. Filling content...`);
          await inputs[1].focus();
          await randomDelay(page, 600, 1200);
          
          // üé≠ For long content, use fill() but with random pauses
          // (Natural typing would take too long for full article)
          console.log('üé≠ Human simulation: Pasting content (simulating Ctrl+V)...');
          await inputs[1].fill(processedContent);
          
          console.log(`‚úÖ Content filled (${processedContent.length} chars)`);
          await randomDelay(page, 500, 1000);
          await page.keyboard.press('Enter');
          await randomDelay(page, 800, 1500);
        }
        
        await randomDelay(page, 1500, 2500);
        
        // Insert image
        console.log(`\nüñºÔ∏è  3. Inserting image...`);
        const imageBtn = await page.$('button.article-editor-desktop--side-button__sideButton-1z[data-tip="–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"]');
        if (imageBtn && article.imageUrl) {
          console.log('üé≠ Human simulation: Clicking image button...');
          await clickNaturally(page, imageBtn);
          console.log(`‚úÖ Image button clicked`);
          await randomDelay(page, 2000, 4000);
          
          const imgInput = await page.$('input[type="text"]');
          if (imgInput) {
            await imgInput.focus();
            await randomDelay(page, 300, 700);
            await imgInput.fill(article.imageUrl);
            console.log(`‚úÖ Image URL inserted`);
            await randomDelay(page, 300, 600);
            await imgInput.press('Enter');
            await randomDelay(page, 800, 1500);
          }
        } else {
          console.log(`‚ÑπÔ∏è  Image skipped (button not found or no URL)`);
        }
        
        await randomDelay(page, 1500, 2500);
        
        // PUBLISH BUTTON 1 - First button in editor header
        console.log(`\nüì§ 4. Clicking first publish button (editor header)...`);
        const publishSelectors = [
          'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å"):not([disabled])',
          'span:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å")',
        ];
        
        let publishClicked = false;
        for (const selector of publishSelectors) {
          try {
            const element = await page.$(selector);
            if (element && await element.isVisible()) {
              console.log(`‚úÖ Found with selector: ${selector}`);
              console.log('üé≠ Human simulation: Clicking publish button...');
              await clickNaturally(page, element);
              console.log(`‚úÖ First publish button clicked`);
              publishClicked = true;
              break;
            }
          } catch (e) {
            console.log(`   ‚ö†Ô∏è  Selector failed: ${selector}`);
          }
        }
        
        if (!publishClicked) {
          console.log(`‚ùå First publish button not found - skipping confirmation button`);
        } else {
          // ‚úÖ FIX: ONLY PROCEED IF FIRST BUTTON WAS CLICKED
          await randomDelay(page, 4000, 6000);
          
          // PUBLISH BUTTON 2 - Confirmation button in modal
          console.log(`\nüì§ 5. Clicking confirmation button (modal)...`);
          
          const confirmSelectors = [
            'button[data-testid="publish-btn"][type="submit"]',
            'button[data-testid="publish-btn"]',
            'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å"):not([disabled])',
            'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Å–µ–π—á–∞—Å"):not([disabled])',
            'button.article-editor-desktop--base-button__primary-1Y:not([disabled])',
            'button[type="submit"]',
          ];
          
          let confirmClicked = false;
          for (const selector of confirmSelectors) {
            try {
              const elements = await page.$$(selector);
              if (elements.length > 0) {
                // Get the last visible button (usually the one in modal)
                for (let i = elements.length - 1; i >= 0; i--) {
                  const el = elements[i];
                  if (await el.isVisible() && await el.isEnabled()) {
                    console.log(`‚úÖ Found with selector: ${selector}`);
                    console.log('üé≠ Human simulation: Clicking confirmation button...');
                    await clickNaturally(page, el);
                    console.log(`‚úÖ Confirmation button clicked`);
                    console.log(`\nüéâ ARTICLE PUBLISHED SUCCESSFULLY!`);
                    console.log(`   Title: "${article.title.substring(0, 50)}..."`);
                    await savePublishedArticle(article);
                    confirmClicked = true;
                    break;
                  }
                }
              }
              if (confirmClicked) break;
            } catch (e) {
              console.log(`   ‚ö†Ô∏è  Selector failed: ${selector}`);
            }
          }
          
          if (!confirmClicked) {
            console.log(`‚ùå Confirmation button not found`);
          }
        }
      }
    }
    
    await randomDelay(page, 3000, 5000);
    await browser.close();
    
    console.log('\n‚úÖ Auto-publisher completed!');
    process.exit(0);
    
  } catch (error) {
    console.error(`\n‚ùå CRITICAL ERROR: ${error.message}`);
    process.exit(1);
  }
})();
