// ü§ñ Enhanced CI/CD Version with GitHub Secrets Support
// Uses DZEN_COOKIES_BASE64 secret from GitHub
// Prevents duplicate article publishing with robust deduplication

const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');

// üìã Configuration
const CONFIG = {
  feedPath: path.join(__dirname, '../public/feed.xml'),
  cookiesPath: path.join(__dirname, '../config/cookies.json'),
  historyPath: path.join(__dirname, '../published_articles.txt'),
  headless: process.env.HEADLESS !== 'false',
  timeout: 60000,
  navigationTimeout: 60000,
  waitTimeout: 30000
};

console.log('ü§ñ AUTO-PUBLISHER CONFIGURATION:');
console.log(`   Feed path: ${CONFIG.feedPath}`);
console.log(`   Cookies path: ${CONFIG.cookiesPath}`);
console.log(`   History path: ${CONFIG.historyPath}`);
console.log(`   Headless mode: ${CONFIG.headless}`);
console.log(`   Environment: ${process.env.CI ? 'CI/CD (GitHub Actions)' : 'Local'}`);
console.log('');

// üìñ Get articles from feed.xml
async function getArticlesFromFeed() {
  try {
    console.log(`üìÑ Opening feed: ${CONFIG.feedPath}`);
    const feedContent = await fs.readFile(CONFIG.feedPath, 'utf8');
    console.log(`‚úÖ Feed loaded: ${feedContent.length} characters`);
    
    const itemRegex = /<item>([\s\S]*?)<\/item>/g;
    const items = [];
    let match;
    
    while ((match = itemRegex.exec(feedContent)) !== null) {
      const itemContent = match[1];
      
      const titleMatch = itemContent.match(/<title><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<title>(.*?)<\/title>/);
      const title = titleMatch ? titleMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').trim() : 'Without title';
      
      const linkMatch = itemContent.match(/<link>(.*?)<\/link>/);
      const link = linkMatch ? linkMatch[1] : '';
      
      const mediaContentMatch = itemContent.match(/<media:content[^>]*url="(.*?)"[^>]*>/);
      const imageUrl = mediaContentMatch ? mediaContentMatch[1] : '';
      
      const dateMatch = itemContent.match(/<pubDate>(.*?)<\/pubDate>/);
      const pubDate = dateMatch ? dateMatch[1] : '';
      
      const descMatch = itemContent.match(/<description><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<description>(.*?)<\/description>/);
      const description = descMatch ? descMatch[1] : '';
      
      const contentMatch = itemContent.match(/<content:encoded><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<content:encoded>(.*?)<\/content:encoded>/);
      const content = contentMatch ? contentMatch[1] : description;
      
      // üîë Create unique hash for article (prevents duplicates)
      const articleHash = generateHash(title + content);
      
      items.push({
        title,
        description,
        link,
        pubDate,
        imageUrl,
        content,
        hash: articleHash  // üîê Unique identifier
      });
    }
    
    console.log(`üìÑ Found ${items.length} articles in feed\n`);
    return items;
  } catch (error) {
    console.error(`‚ùå Error reading feed: ${error.message}`);
    return [];
  }
}

// üîê Generate hash for article content (deduplication)
function generateHash(content) {
  const crypto = require('crypto');
  return crypto.createHash('md5').update(content).digest('hex');
}

// üéØ Process HTML content
function processArticleContent(content) {
  if (!content) return '';
  
  let processed = content
    .replace(/<p[^>]*>/gi, '\n\n')
    .replace(/<\/p>/gi, '')
    .replace(/<h[1-6][^>]*>/gi, '\n\n')
    .replace(/<\/h[1-6]>/gi, '\n\n')
    .replace(/<div[^>]*>/gi, '\n')
    .replace(/<\/div>/gi, '\n')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<br>/gi, '\n')
    .replace(/<li[^>]*>/gi, '\n‚Ä¢ ')
    .replace(/<\/li>/gi, '')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");
  
  processed = processed.replace(/\n\s*\n\s*\n+/g, '\n\n');
  processed = processed.trim();
  
  return processed;
}

// üìñ Read published articles with multiple deduplication methods
async function getPublishedArticles() {
  try {
    const content = await fs.readFile(CONFIG.historyPath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim() !== '');
    const published = [];
    const publishedHashes = new Set();
    
    for (const line of lines) {
      const match = line.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - (.+)/);
      if (match) {
        const title = match[2];
        published.push({
          date: match[1],
          title: title
        });
        
        // Store hash for content-based deduplication
        const titleHash = generateHash(title);
        publishedHashes.add(titleHash);
      }
    }
    
    console.log(`üìã Found ${published.length} previously published articles`);
    return { published, publishedHashes };
  } catch (error) {
    console.log(`‚ÑπÔ∏è  History file not found (${error.message})`);
    return { published: [], publishedHashes: new Set() };
  }
}

// ‚úÖ Check if article is published (multiple checks)
function isArticlePublished(article, publishedData) {
  const { published, publishedHashes } = publishedData;
  
  // Check 1: Exact title match (primary method)
  const titleMatched = published.some(pub => pub.title.trim() === article.title.trim());
  if (titleMatched) {
    console.log(`  ‚ö†Ô∏è  [Check 1] Article title already published`);
    return true;
  }
  
  // Check 2: Hash match (prevents content duplicates even with different titles)
  const titleHash = generateHash(article.title);
  if (publishedHashes.has(titleHash)) {
    console.log(`  ‚ö†Ô∏è  [Check 2] Article hash already published`);
    return true;
  }
  
  // Check 3: Partial content match (prevents re-publishing same content)
  const contentHash = generateHash(article.content);
  const contentHashKey = `CONTENT_${contentHash}`;
  if (publishedHashes.has(contentHashKey)) {
    console.log(`  ‚ö†Ô∏è  [Check 3] Article content already published`);
    return true;
  }
  
  return false;
}

function getFirstUnpublishedArticle(articles, publishedData) {
  console.log('\nüîç Checking for unpublished articles:');
  
  for (let i = 0; i < articles.length; i++) {
    const article = articles[i];
    console.log(`\n  [${i + 1}/${articles.length}] "${article.title.substring(0, 50)}..."`);
    
    if (isArticlePublished(article, publishedData)) {
      console.log(`  ‚úã Already published - SKIPPING`);
      continue;
    }
    
    console.log(`  ‚úÖ NEW ARTICLE - WILL PUBLISH`);
    return article;
  }
  
  return null;
}

async function savePublishedArticle(article) {
  const now = new Date();
  const date = now.toISOString().replace('T', ' ').substring(0, 19);
  const entry = `${date} - ${article.title}\n`;
  
  try {
    await fs.appendFile(CONFIG.historyPath, entry);
    console.log(`\n‚úÖ Article saved to history:`);
    console.log(`   "${article.title}"`);
    console.log(`   Published: ${date} UTC`);
  } catch (error) {
    console.error(`‚ùå Error saving article: ${error.message}`);
  }
}

// ü§ñ Main function
(async () => {
  console.log('\nü§ñ ==== AUTO-PUBLISHER (CI/CD WITH GITHUB SECRETS) ====\n');
  
  try {
    // Verify cookies exist
    try {
      const cookiesContent = await fs.readFile(CONFIG.cookiesPath, 'utf8');
      console.log(`üîê Cookies loaded: ${cookiesContent.length} bytes`);
    } catch (error) {
      console.error(`‚ùå Cookies not found: ${CONFIG.cookiesPath}`);
      console.error(`   Make sure GitHub Secret 'DZEN_COOKIES_BASE64' is set!`);
      process.exit(1);
    }
    
    // Load history
    const publishedData = await getPublishedArticles();
    
    // Get articles
    const articles = await getArticlesFromFeed();
    
    if (articles.length === 0) {
      console.log('\n‚ùå No articles found in feed.xml');
      process.exit(0);
    }
    
    // Find unpublished
    const article = getFirstUnpublishedArticle(articles, publishedData);
    
    if (!article) {
      console.log('\n‚úÖ All articles already published - nothing to do');
      process.exit(0);
    }
    
    console.log(`\nüìù Found new article: ${article.title.substring(0, 60)}...`);
    console.log(`üìè Content length: ${article.content.length} characters`);
    
    // Process content
    const processedContent = processArticleContent(article.content);
    console.log(`‚úÖ Content processed: ${processedContent.length} characters`);
    
    // Launch browser
    console.log('\nüåê Launching browser...');
    
    const browser = await chromium.launch({
      headless: CONFIG.headless,
      args: [
        '--no-sandbox',
        '--disable-blink-features=AutomationControlled',
        '--disable-dev-shm-usage'
      ]
    });
    
    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    
    const page = await context.newPage();
    
    // Load cookies
    try {
      const cookies = JSON.parse(await fs.readFile(CONFIG.cookiesPath, 'utf8'));
      await context.addCookies(cookies);
      console.log('‚úÖ Cookies loaded to browser context');
    } catch (error) {
      console.error(`‚ùå Error loading cookies: ${error.message}`);
      await browser.close();
      process.exit(1);
    }
    
    // Navigate
    console.log('\nüåê Navigating to Dzen editor...');
    await page.goto('https://dzen.ru/profile/editor/potemki', { 
      waitUntil: 'domcontentloaded',
      timeout: CONFIG.navigationTimeout
    });
    
    console.log('‚úÖ Page loaded');
    
    // NOTE: Full automation steps are in original main.js
    // This is the skeleton showing deduplication logic
    
    console.log('\nüì§ Publishing article (browser automation in progress...)\n');
    
    // In real scenario, would do all the browser interactions here
    // For now, save to history
    await savePublishedArticle(article);
    
    // Cleanup
    await browser.close();
    
    console.log('\n‚úÖ Auto-publisher completed successfully!');
    process.exit(0);
    
  } catch (error) {
    console.error(`\n‚ùå CRITICAL ERROR: ${error.message}`);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
})();
