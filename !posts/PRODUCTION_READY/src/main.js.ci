// ü§ñ CI/CD Version - Full Automation with Environment Variable Cookies
const { chromium } = require('playwright');
const fs = require('fs').promises;
const path = require('path');

// üìã Configuration
const CONFIG = {
  cookiesSource: process.env.CI ? 'ENVIRONMENT' : 'FILE',
  cookiesPath: path.join(__dirname, '../config/cookies.json'),
  feedPath: path.join(path.dirname(path.dirname(path.dirname(__dirname))), 'public', 'feed.xml'),
  historyPath: path.join(__dirname, '../published_articles.txt'),
  headless: process.env.HEADLESS !== 'false',
  timeout: 60000,
  navigationTimeout: 60000,
  waitTimeout: 30000
};

console.log('ü§ñ AUTO-PUBLISHER CONFIGURATION:');
console.log(`   __dirname: ${__dirname}`);
console.log(`   Feed path: ${CONFIG.feedPath}`);
console.log(`   History path: ${CONFIG.historyPath}`);
console.log(`   Cookies source: ${CONFIG.cookiesSource}`);
if (CONFIG.cookiesSource === 'FILE') {
  console.log(`   Cookies file: ${CONFIG.cookiesPath}`);
} else {
  console.log(`   Cookies from: DZEN_COOKIES_JSON environment variable (SECURE!)`);
}
console.log(`   Headless mode: ${CONFIG.headless}`);
console.log(`   Environment: ${process.env.CI ? 'CI/CD (GitHub Actions)' : 'Local'}`);
console.log('');

// üìñ Get articles from feed.xml
async function getArticlesFromFeed() {
  try {
    console.log(`üìÑ Opening feed: ${CONFIG.feedPath}`);
    const feedContent = await fs.readFile(CONFIG.feedPath, 'utf8');
    console.log(`‚úÖ Feed loaded: ${feedContent.length} characters`);
    
    const itemRegex = /<item>([\s\S]*?)<\/item>/g;
    const items = [];
    let match;
    
    while ((match = itemRegex.exec(feedContent)) !== null) {
      const itemContent = match[1];
      
      const titleMatch = itemContent.match(/<title><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<title>(.*?)<\/title>/);
      const title = titleMatch ? titleMatch[1].replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').trim() : 'Without title';
      
      const linkMatch = itemContent.match(/<link>(.*?)<\/link>/);
      const link = linkMatch ? linkMatch[1] : '';
      
      const mediaContentMatch = itemContent.match(/<media:content[^>]*url="(.*?)"[^>]*>/);
      const imageUrl = mediaContentMatch ? mediaContentMatch[1] : '';
      
      const dateMatch = itemContent.match(/<pubDate>(.*?)<\/pubDate>/);
      const pubDate = dateMatch ? dateMatch[1] : '';
      
      const descMatch = itemContent.match(/<description><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<description>(.*?)<\/description>/);
      const description = descMatch ? descMatch[1] : '';
      
      const contentMatch = itemContent.match(/<content:encoded><!\[CDATA\[(.*?)\]\]>/) || itemContent.match(/<content:encoded>(.*?)<\/content:encoded>/);
      const content = contentMatch ? contentMatch[1] : description;
      
      items.push({
        title,
        description,
        link,
        pubDate,
        imageUrl,
        content
      });
    }
    
    console.log(`üìÑ Found ${items.length} articles in feed\n`);
    return items;
  } catch (error) {
    console.error(`‚ùå Error reading feed: ${error.message}`);
    return [];
  }
}

// üèÑ Process HTML content
function processArticleContent(content) {
  if (!content) return '';
  
  let processed = content
    .replace(/<p[^>]*>/gi, '\n\n')
    .replace(/<\/p>/gi, '')
    .replace(/<h[1-6][^>]*>/gi, '\n\n')
    .replace(/<\/h[1-6]>/gi, '\n\n')
    .replace(/<div[^>]*>/gi, '\n')
    .replace(/<\/div>/gi, '\n')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<br>/gi, '\n')
    .replace(/<li[^>]*>/gi, '\n‚Ä¢ ')
    .replace(/<\/li>/gi, '')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");
  
  processed = processed.replace(/\n\s*\n\s*\n+/g, '\n\n');
  processed = processed.trim();
  
  return processed;
}

// üìñ Load cookies (from file or environment variable)
async function loadCookies() {
  try {
    let cookiesJson;
    
    if (process.env.CI) {
      cookiesJson = process.env.DZEN_COOKIES_JSON;
      
      if (!cookiesJson || cookiesJson.length < 10) {
        throw new Error('DZEN_COOKIES_JSON environment variable is empty!');
      }
      
      console.log(`üîê Cookies loaded from environment variable (CI/CD)`);
      console.log(`   Size: ${cookiesJson.length} characters`);
    } else {
      cookiesJson = await fs.readFile(CONFIG.cookiesPath, 'utf8');
      console.log(`üîê Cookies loaded from file: ${CONFIG.cookiesPath}`);
      console.log(`   Size: ${cookiesJson.length} characters`);
    }
    
    try {
      const cookies = JSON.parse(cookiesJson);
      console.log(`‚úÖ Valid JSON format (${Array.isArray(cookies) ? cookies.length : 1} items)\n`);
      return cookies;
    } catch (e) {
      throw new Error(`Invalid JSON format: ${e.message}`);
    }
  } catch (error) {
    console.error(`‚ùå Error loading cookies: ${error.message}`);
    if (process.env.CI) {
      console.error(`   Make sure GitHub Secret 'DZEN_COOKIES_JSON' is set!`);
    }
    throw error;
  }
}

// üìñ Read published articles
async function getPublishedArticles() {
  try {
    const content = await fs.readFile(CONFIG.historyPath, 'utf8');
    const lines = content.split('\n').filter(line => line.trim() !== '');
    const published = [];
    
    for (const line of lines) {
      const match = line.match(/(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - (.+)/);
      if (match) {
        published.push({
          date: match[1],
          title: match[2]
        });
      }
    }
    
    console.log(`üìã Found ${published.length} previously published articles`);
    return published;
  } catch (error) {
    console.log(`‚ÑπÔ∏è  History file not found (${error.message})`);
    return [];
  }
}

function isArticlePublished(articleTitle, publishedArticles) {
  return publishedArticles.some(pub => pub.title.trim() === articleTitle.trim());
}

function getFirstUnpublishedArticle(articles, publishedArticles) {
  console.log('\nüîç Checking for unpublished articles:');
  
  for (let i = 0; i < articles.length; i++) {
    const article = articles[i];
    console.log(`\n  [${i + 1}/${articles.length}] "${article.title.substring(0, 50)}..."`);
    
    if (isArticlePublished(article.title, publishedArticles)) {
      console.log(`  ‚úã Already published - SKIPPING`);
      continue;
    }
    
    console.log(`  ‚úÖ NEW ARTICLE - WILL PUBLISH`);
    return article;
  }
  
  return null;
}

async function savePublishedArticle(article) {
  const now = new Date();
  const date = now.toISOString().replace('T', ' ').substring(0, 19);
  const entry = `${date} - ${article.title}\n`;
  
  try {
    await fs.appendFile(CONFIG.historyPath, entry);
    console.log(`\n‚úÖ Article saved to history:`);
    console.log(`   "${article.title}"`);
    console.log(`   Published: ${date} UTC`);
  } catch (error) {
    console.error(`‚ùå Error saving article: ${error.message}`);
  }
}

// ü§ñ Main function
(async () => {
  console.log('\nü§ñ ==== AUTO-PUBLISHER STARTING ====\n');
  
  try {
    // üîê Load cookies from secure source
    const cookies = await loadCookies();
    
    // Load history
    const publishedArticles = await getPublishedArticles();
    
    // Get articles
    const articles = await getArticlesFromFeed();
    
    if (articles.length === 0) {
      console.log('\n‚ùå No articles found in feed.xml');
      process.exit(0);
    }
    
    // Find unpublished
    const article = getFirstUnpublishedArticle(articles, publishedArticles);
    
    if (!article) {
      console.log('\n‚úÖ All articles already published - nothing to do');
      process.exit(0);
    }
    
    console.log(`\nüìù Found new article: ${article.title.substring(0, 60)}...`);
    console.log(`üìÑ Content length: ${article.content.length} characters`);
    console.log(`üîç First 100 chars: ${article.content.substring(0, 100)}...`);
    
    // Process content
    const processedContent = processArticleContent(article.content);
    console.log(`‚úÖ Content processed: ${processedContent.length} characters`);
    console.log(`üîç First 100 chars after processing: ${processedContent.substring(0, 100)}...`);
    
    // Launch browser
    console.log('\nüåê Launching browser...');
    
    const browser = await chromium.launch({
      headless: CONFIG.headless,
      args: [
        '--no-sandbox',
        '--disable-blink-features=AutomationControlled',
        '--disable-dev-shm-usage'
      ]
    });
    
    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    
    const page = await context.newPage();
    
    // Use cookies
    try {
      await context.addCookies(cookies);
      console.log(`‚úÖ Cookies added to browser context (${cookies.length} cookies)`);
    } catch (error) {
      console.error(`‚ùå Error adding cookies: ${error.message}`);
      await browser.close();
      process.exit(1);
    }
    
    // Navigate
    console.log('\nüåê Navigating to Dzen editor...');
    await page.goto('https://dzen.ru/profile/editor/potemki', { 
      waitUntil: 'domcontentloaded',
      timeout: CONFIG.navigationTimeout
    });
    
    console.log('‚úÖ Page loaded');
    await page.waitForTimeout(5000);
    
    // Close modal if exists
    const modalCloseButton = await page.$('[data-testid="close-button"]');
    if (modalCloseButton) {
      await modalCloseButton.click();
      console.log('‚úÖ Closed modal window');
      await page.waitForTimeout(2000);
    }
    
    // Click add publication button
    const addPublicationButton = await page.$('[data-testid="add-publication-button"]');
    if (addPublicationButton) {
      await addPublicationButton.click();
      console.log('‚úÖ Add publication button clicked');
      
      await page.waitForTimeout(3000);
      
      // Click "Write article"
      const writeArticleButton = await page.$('text="–ù–∞–ø–∏—Å–∞—Ç—å —Å—Ç–∞—Ç—å—é"');
      if (writeArticleButton) {
        await writeArticleButton.click();
        console.log('‚úÖ "Write article" button clicked');
        
        await page.waitForTimeout(8000);
        
        // Close help popup
        await page.evaluate(() => {
          const overlays = document.querySelectorAll('.ReactModal__Overlay, .ReactModalPortal, .article-editor-desktop--help-popup__overlay-3q');
          overlays.forEach(overlay => {
            overlay.style.display = 'none';
            overlay.style.visibility = 'hidden';
            overlay.style.pointerEvents = 'none';
            overlay.remove();
          });
        });
        
        await page.keyboard.press('Escape');
        console.log('‚úÖ Closed help popup');
        await page.waitForTimeout(2000);
        await page.waitForTimeout(3000);
        
        // üîç FIND ALL INPUT FIELDS AND ANALYZE THEM
        console.log('\nüîç === ANALYZING AVAILABLE INPUT FIELDS ===\n');
        const allEditableElements = await page.$$('input[type="text"], textarea, div[contenteditable="true"]');
        console.log(`üîç Found ${allEditableElements.length} editable fields\n`);
        
        // GET DETAILED INFORMATION ABOUT EACH FIELD
        const fieldInfo = await page.evaluate(() => {
          const elements = Array.from(document.querySelectorAll('input[type="text"], textarea, div[contenteditable="true"]'));
          return elements.map((el, index) => {
            return {
              index: index,
              tagName: el.tagName,
              id: el.id || 'none',
              className: el.className || 'none',
              placeholder: el.getAttribute('placeholder') || 'none',
              ariaLabel: el.getAttribute('aria-label') || 'none',
              contentEditable: el.getAttribute('contenteditable') || 'none',
              role: el.getAttribute('role') || 'none',
              textContent: (el.textContent || el.getAttribute('value') || '').substring(0, 30),
              isVisible: el.offsetParent !== null,
              offsetHeight: el.offsetHeight,
              offsetWidth: el.offsetWidth
            };
          });
        });
        
        console.log('üìã === FIELD ANALYSIS RESULTS ===\n');
        fieldInfo.forEach((field, idx) => {
          console.log(`[${idx + 1}] ${field.tagName}`);
          console.log(`    ID: ${field.id}`);
          console.log(`    Class: ${field.className}`);
          console.log(`    Placeholder: "${field.placeholder}"`);
          console.log(`    Aria-label: "${field.ariaLabel}"`);
          console.log(`    Role: ${field.role}`);
          console.log(`    Text: "${field.textContent}"`);
          console.log(`    Visible: ${field.isVisible} | Size: ${field.offsetWidth}x${field.offsetHeight}`);
          console.log('');
        });
        
        // 1. FILL TITLE
        console.log('\nüìù === 1. FILLING TITLE ===\n');
        
        let titleElement = null;
        let titleElementIndex = -1;
        
        // Try to find title field by aria-label or placeholder
        for (let i = 0; i < allEditableElements.length; i++) {
          const field = fieldInfo[i];
          
          if (field.ariaLabel.toLowerCase().includes('–∑–∞–≥–æ–ª–æ–≤') || 
              field.ariaLabel.toLowerCase().includes('title') ||
              field.placeholder.toLowerCase().includes('–∑–∞–≥–æ–ª–æ–≤') ||
              field.placeholder.toLowerCase().includes('title')) {
            
            if (field.isVisible) {
              const element = allEditableElements[i];
              await element.focus();
              await element.fill(article.title);
              console.log(`‚úÖ Title filled in field [${i + 1}]`);
              console.log(`   Aria-label: "${field.ariaLabel}"`);
              console.log(`   Placeholder: "${field.placeholder}"`);
              console.log(`   Title: "${article.title.substring(0, 50)}..."`);
              titleElement = element;
              titleElementIndex = i;
              break;
            }
          }
        }
        
        // If title field not found, use first visible field
        if (!titleElement && allEditableElements.length > 0) {
          console.log('‚ÑπÔ∏è  Title field not found by attributes, using first field');
          const field = fieldInfo[0];
          if (field.isVisible) {
            const element = allEditableElements[0];
            await element.focus();
            await element.fill(article.title);
            console.log(`‚úÖ Title filled in field [1] (first available)`);
            console.log(`   Title: "${article.title.substring(0, 50)}..."`);
            titleElement = element;
            titleElementIndex = 0;
          }
        }
        
        if (!titleElement) {
          console.log('‚ùå Could not find title field');
        } else {
          await page.waitForTimeout(1000);
        }
        
        // 2. FILL CONTENT
        console.log('\nüìù === 2. FILLING ARTICLE CONTENT ===\n');
        
        let contentElement = null;
        let contentElementIndex = -1;
        
        // Find content field (not title)
        for (let i = 0; i < allEditableElements.length; i++) {
          const field = fieldInfo[i];
          
          // Skip title fields
          if (field.ariaLabel.toLowerCase().includes('–∑–∞–≥–æ–ª–æ–≤') || 
              field.ariaLabel.toLowerCase().includes('title') ||
              field.placeholder.toLowerCase().includes('–∑–∞–≥–æ–ª–æ–≤') ||
              field.placeholder.toLowerCase().includes('title')) {
            continue;
          }
          
          if (field.isVisible && i !== titleElementIndex) {
            const element = allEditableElements[i];
            await element.focus();
            await element.fill(processedContent);
            console.log(`‚úÖ Content filled in field [${i + 1}]`);
            console.log(`   Aria-label: "${field.ariaLabel}"`);
            console.log(`   Placeholder: "${field.placeholder}"`);
            console.log(`   Content length: ${processedContent.length} characters`);
            console.log(`   First 50 chars: "${processedContent.substring(0, 50)}..."`);
            contentElement = element;
            contentElementIndex = i;
            break;
          }
        }
        
        if (!contentElement) {
          console.log('‚ùå Could not find content field');
        } else {
          await page.keyboard.press('Enter');
          console.log('‚úÖ Pressed Enter after content');
          await page.waitForTimeout(1000);
        }
        
        await page.waitForTimeout(2000);
        
        // 3. INSERT IMAGE
        console.log('\nüñºÔ∏è  === 3. INSERTING IMAGE ===\n');
        
        const imageButtonSelector = 'button.article-editor-desktop--side-button__sideButton-1z[data-tip="–í—Å—Ç–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"]';
        try {
          const imageButton = await page.$(imageButtonSelector);
          if (imageButton) {
            console.log(`‚úÖ Found image button: ${imageButtonSelector}`);
            await imageButton.click();
            await page.waitForTimeout(3000);
            
            if (article.imageUrl) {
              const imageInputSelectors = [
                'input[placeholder*="—Å—Å—ã–ª–∫–∞"]',
                'input[placeholder*="url"]',
                'input[placeholder*="–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"]',
                'input[type="text"]',
                'input'
              ];
              
              let imageInputFound = false;
              for (const imgInputSel of imageInputSelectors) {
                const imageInput = await page.$(imgInputSel);
                if (imageInput && await imageInput.isVisible()) {
                  await imageInput.fill(article.imageUrl);
                  console.log(`‚úÖ Image URL filled`);
                  console.log(`   Selector: ${imgInputSel}`);
                  console.log(`   URL: ${article.imageUrl.substring(0, 50)}...`);
                  await imageInput.press('Enter');
                  await page.waitForTimeout(1000);
                  imageInputFound = true;
                  break;
                }
              }
              
              if (!imageInputFound) {
                console.log('‚ùå Image URL input field not found');
              }
            } else {
              console.log('‚ÑπÔ∏è  Image URL not available');
            }
          } else {
            console.log(`‚ùå Image button not found: ${imageButtonSelector}`);
          }
        } catch (e) {
          console.log('‚ùå Image insertion error:', e.message);
        }
        
        await page.waitForTimeout(2000);
        
        // 4. FIRST PUBLISH BUTTON
        console.log('\nüì§ === 4. CLICKING FIRST PUBLISH BUTTON ===\n');
        
        const publishSelectors = [
          '[data-testid="publish-btn"]',
          'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å"):not([disabled])',
          'button[class*="publish"]'
        ];
        
        let publishClicked = false;
        for (const selector of publishSelectors) {
          const publishButton = await page.$(selector);
          if (publishButton && await publishButton.isVisible() && await publishButton.isEnabled()) {
            console.log(`‚úÖ Found and clicked publish button`);
            console.log(`   Selector: ${selector}`);
            await publishButton.click();
            publishClicked = true;
            break;
          }
        }
        
        if (!publishClicked) {
          console.log('‚ö†Ô∏è  First publish button not found');
        }
        
        await page.waitForTimeout(5000);
        
        // 5. SECOND PUBLISH BUTTON (confirmation)
        console.log('\nüì§ === 5. CLICKING CONFIRMATION PUBLISH BUTTON ===\n');
        
        const secondPublishButtonSelector = 'button[data-testid="publish-btn"][type="submit"]';
        try {
          const secondPublishButton = await page.$(secondPublishButtonSelector);
          if (secondPublishButton && await secondPublishButton.isVisible() && await secondPublishButton.isEnabled()) {
            console.log(`‚úÖ Found confirmation publish button`);
            console.log(`   Selector: ${secondPublishButtonSelector}`);
            await secondPublishButton.click();
            console.log('\nüéâ ARTICLE PUBLISHED SUCCESSFULLY!');
            console.log(`   Title: "${article.title}"`);
            console.log(`   Content length: ${processedContent.length} characters`);
            console.log(`   Image: ${article.imageUrl || 'none'}`);
            
            // Save to history
            await savePublishedArticle(article);
          } else {
            console.log(`‚ùå Confirmation publish button not found: ${secondPublishButtonSelector}`);
            
            // Try alternative selectors
            const altSelectors = [
              'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å"):not([disabled]):not([aria-disabled="true"])',
              'button:has-text("–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Å–µ–π—á–∞—Å"):not([disabled]):not([aria-disabled="true"])',
              'button:has-text("–î–∞"):not([disabled]):not([aria-disabled="true"])'
            ];
            
            let altFound = false;
            for (const altSel of altSelectors) {
              const altButton = await page.$(altSel);
              if (altButton && await altButton.isVisible() && await altButton.isEnabled()) {
                console.log(`‚úÖ Found alternative confirmation button`);
                console.log(`   Selector: ${altSel}`);
                await altButton.click();
                console.log('\nüéâ ARTICLE PUBLISHED SUCCESSFULLY (via alternative selector)!');
                await savePublishedArticle(article);
                altFound = true;
                break;
              }
            }
            
            if (!altFound) {
              console.log('‚ö†Ô∏è  No confirmation button found - publication may have failed');
            }
          }
        } catch (e) {
          console.log('‚ùå Error with confirmation button:', e.message);
        }
      }
    }
    
    await page.waitForTimeout(5000);
    await browser.close();
    
    console.log('\n‚úÖ Auto-publisher completed!');
    process.exit(0);
    
  } catch (error) {
    console.error(`\n‚ùå CRITICAL ERROR: ${error.message}`);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
})();
